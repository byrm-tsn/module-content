# Software Development 2 Lab 06 -- Inline Assembly Programming

<script src="https://cdn.jsdelivr.net/npm/code-line"></script>
<script>CodeLine.initOnPageLoad({toggleBtn: {show: false}, copyBtn: {show: false}})</script>

<link rel="stylesheet" href="/module-content/css/block.css">

**WARNING -- before starting this lab it is recommended that you use a Windows machine only with the Microsoft compiler. Assembly is platform specific and we will only cover the Microsoft toolchain.**

We've looked at how our C data values are represented in memory (their *low-level representation*).  In this unit we will look closer at how our operations are represented.  This requires us to look at assembly code.

If we look at how a compiler works, we can take the following high-level view:

*C Code* **&rarr;** *Assembly Code* **&rarr;** *Object Code* **&rarr;** *Executable*

In this unit we will look at how we can use assembly code directly in our C code.  This can be very useful if you ever want to undertake very low-level optimisation.  However, for our purposes we are trying to understand how our C code translates to assembly code.  This allows us to understand our code in more detail.  In general, you are unlikely to write inline assembly in all but the most rare circumstances as a C and C++ programmer.  However, understanding what your code looks like on the machine is very useful.

One thing to remember is that assembly code is architecture specific.  That is, the assembly code that works on a standard PC generally won't work on your mobile phone (unless it uses a Intel based CPU).  Programming in assembly is very platform specific, hence the performance gains it can give.

## Outputting Assembly Code

The building of an program is a two step process.  C is considered a good systems' programming language as it has a very close resemblance to assembly code.  We can make the `cl` compiler output assembly code for us to see the result.

> **What is Assembly Code?**
>
> You will have hopefully been exposed to assembly code in Computer Systems.  Assembly code is a language which provides human readable versions of machine level instructions.  We will be looking in more detail at how the CPU executes instructions and writing some assembly code later in the module.  What you will find is that you can translate from C to assembly fairly easily.

Let us go through this extra step using our Hello World example.  Just as a refresh, the code for this is given below:

```c
// stdio contains standard C input-output functions
#include <stdio.h>

// Our main function.  
int main(int argc, char **argv)
{
    // Print hello world to the screen
    printf("Hello world!\n");
    // Return value from program
    return 0;
}
```

To output assembly code using the `cl` compiler during our compilation step we use the `/Fa` compiler flag:

```c
cl /c /Fa hello.c
```

You will now find that you have a `hello.asm` file produced.  It should look similar to the following:

```assembly
; Listing generated by Microsoft (R) Optimizing Compiler Version 19.28.29336.0 

	TITLE	C:\Users\student\Documents\software-development-2\hello.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	___local_stdio_printf_options
PUBLIC	__vfprintf_l
PUBLIC	_printf
PUBLIC	_main
EXTRN	___acrt_iob_func:PROC
EXTRN	___stdio_common_vfprintf:PROC
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
_DATA	SEGMENT
$SG9187	DB	'Hello world!', 0aH, 00H
_DATA	ENDS
; Function compile flags: /Odtp
_TEXT	SEGMENT
_argc$ = 8						; size = 4
_argv$ = 12						; size = 4
_main	PROC
; File C:\Users\student\Documents\software-development-2\hello.c
; Line 6
	push	ebp
	mov	ebp, esp
; Line 8
	push	OFFSET $SG9187
	call	_printf
	add	esp, 4
; Line 10
	xor	eax, eax
; Line 11
	pop	ebp
	ret	0
_main	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT _printf
_TEXT	SEGMENT
__Result$ = -8						; size = 4
__ArgList$ = -4						; size = 4
__Format$ = 8						; size = 4
_printf	PROC						; COMDAT
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.18362.0\ucrt\stdio.h
; Line 954
	push	ebp
	mov	ebp, esp
	sub	esp, 8
; Line 957
	lea	eax, DWORD PTR __Format$[ebp+4]
	mov	DWORD PTR __ArgList$[ebp], eax
; Line 958
	mov	ecx, DWORD PTR __ArgList$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR __Format$[ebp]
	push	edx
	push	1
	call	___acrt_iob_func
	add	esp, 4
	push	eax
	call	__vfprintf_l
	add	esp, 16					; 00000010H
	mov	DWORD PTR __Result$[ebp], eax
; Line 959
	mov	DWORD PTR __ArgList$[ebp], 0
; Line 960
	mov	eax, DWORD PTR __Result$[ebp]
; Line 961
	mov	esp, ebp
	pop	ebp
	ret	0
_printf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT __vfprintf_l
_TEXT	SEGMENT
__Stream$ = 8						; size = 4
__Format$ = 12						; size = 4
__Locale$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vfprintf_l PROC					; COMDAT
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.18362.0\ucrt\stdio.h
; Line 642
	push	ebp
	mov	ebp, esp
; Line 643
	mov	eax, DWORD PTR __ArgList$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Locale$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Format$[ebp]
	push	edx
	mov	eax, DWORD PTR __Stream$[ebp]
	push	eax
	call	___local_stdio_printf_options
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	call	___stdio_common_vfprintf
	add	esp, 24					; 00000018H
; Line 644
	pop	ebp
	ret	0
__vfprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.18362.0\ucrt\corecrt_stdio_config.h
; Line 86
	push	ebp
	mov	ebp, esp
; Line 88
	mov	eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage
; Line 89
	pop	ebp
	ret	0
___local_stdio_printf_options ENDP
_TEXT	ENDS
END
```

OK, this might seem daunting, but we can actually break this down a little. We are only interested in this segment:

```assembly
_DATA	SEGMENT
$SG9187	DB	'Hello world!', 0aH, 00H
_DATA	ENDS
; Function compile flags: /Odtp
_TEXT	SEGMENT
_argc$ = 8						; size = 4
_argv$ = 12						; size = 4
_main	PROC
; File C:\Users\student\Documents\software-development-2\hello.c
; Line 6
	push	ebp
	mov	ebp, esp
; Line 8
	push	OFFSET $SG9187
	call	_printf
	add	esp, 4
; Line 10
	xor	eax, eax
; Line 11
	pop	ebp
	ret	0
_main	ENDP
_TEXT	ENDS
```

- Line 2 stores the `Hello world!` message and allocates an identifier (the `$SG9187` part). It has the characters of the message, followed by the hex values `0a` (10) and `00`. The `H` after these values denote them as hex. If you look up an ASCII table, you will see that 10 is a line feed (the new line character) and 0 is null (the null terminator). We've covered these ideas before.
- Line 8 is the start of the main procedure -- `_main PROC`.
- The assembly then tells us which instructions match our C code.
  - Line 6 of `hello.c` is the start of the `main` function.
    - `push ebb` and `mov ebp, esp` are setting the stack. We will look at the stack in more detail later in the module.
  - Line 8 of `hello.c` is `printf(...)`
    - `push OFFSET $SG9187â€‹` will push the memory location of our message onto the stack to be used by `printf`.
    - `call _printf` calls the `printf` function.
    - `add esp, 4` resets the stack, removing the message.
  - Line 10 or `hello.c` is `return 0`
    - `xor eax, eax` just sets the `eax` register to 0. It is the fastest way to do so. We need to set `eax` to 0 to ensure it doesn't conflict with future calculations. We are effectively reseting it. The actual `return 0` is next.
  - Line 11 of `hello.c` is the end of the `main` function.
    - `pop ebp` resets the stack to what it was before `main` started.
    - `ret 0` is the `return 0` call, ending the `main` function.

The lines starting with `;` are comments.  Some of these comments tell you where these lines of code relate to our original C.

## First Inline Assembly Application

Let us look at how we add assembly code to our C code.  **The approach we take is supported by the Microsoft compiler, and will not guaranteed to work in other compilers.**  You should read the necessary documentation for these compilers to discover how to write inline assembly for them.

> **Declaring an Inline Assembly Block**
>
> To use inline assembly in our C code we have to declare a block of code as being assembly.  For the Microsoft compiler we do this as follows:
>
> ```c
> __asm
> {
> 	// Assembly commands go here
> }
> ```
>
> The assembly block can access any values that are accessible where the assembly block is declared.  Any local variables to the function and any global variables can be accessed via their name.  The C compiler will generate the proper assembly code to use them.

We won't really look at assembly code instructions supported by standard x86 processors in any detail.  The following table provides an overview of the instructions we will use in this unit.

| **Instruction** | **Parameters**     | **Description**                                              |
| --------------- | ------------------ | ------------------------------------------------------------ |
| `mov`           | destination source | Moves the value stored in source to the destination.  At least one of the two parameters must be a register |
| `add`           | destination source | Adds the value source to the value destination.  The result is stored in destination. Destination needs to be a register. |
| `push`          | source             | Pushes value stored in source onto the local stack.  We will discuss the stack during this unit, and look at its limitations later in the module. |
| `pop`           | destination        | Pops a value from the local stack into the destination.      |
| `call`          | procedure name     | Executes the given procedure.  We will look at what this means in later in the unit. |
| `jmp`           | location           | Causes control to jump to the location given.  Jumping allows us to implement branching instructions like `if` and `while`. |
| `cmp`           | value1 value2      | Compares the two values.  Sets relevant flags on the CPU based on the outcome of the comparison.  Allows conditional jumping. |
| `jge`           | location           | A jump instruction that jumps if the result of a comparison set the greater than flag. |

Let us now write our first application using inline assembly.  Our application will declare two values (in standard C) and print out their values.  Our assembly block will then store the value of one variable into the other.  Finally we will print the values again (in standard C).

To store one variable into the other we use the following process:

- Load (using `mov`) the first value into the `eax` register (the `eax` register is the standard accumulator register)
- Load (using `mov`) the value store in the `eax` register into the second value.
  \end{enumerate}

And that is it.  This is essentially equivalent to the following command:

```c
x = y;
```

The code for this application is given below.  As you can see it is very simple. **Add this code file now -- `assemble.c`**:

```c
#include <stdio.h>

int main(int argc, char **argv)
{
  int x = 500;
  int y = 0;

  printf("Before assembly, x = %d, y = %d\n", x, y);

  __asm
  {
    mov eax, x
    mov y, eax
  }

  printf("After assembly, x = %d, y = %d\n", x, y);
  return 0;
}
```

For this application we want to generate the assembly code again.  Remember to do this we use `cl` as follows:

```shell
cl /c /Fa assemble.c
```

Once you have generated your assembly code, open the `.asm` file.  We are only interested in the `main` function again, so the assembly segment of interest is as follows:

```assembly
_DATA	SEGMENT
$SG9189	DB	'Before assembly, x = %d, y = %d', 0aH, 00H
	ORG $+3
$SG9190	DB	'After assembly, x = %d, y = %d', 0aH, 00H
_DATA	ENDS
; Function compile flags: /Odtp
_TEXT	SEGMENT
_x$ = -8						; size = 4
_y$ = -4						; size = 4
_argc$ = 8						; size = 4
_argv$ = 12						; size = 4
_main	PROC
; File C:\Users\student\Documents\software-development-2\assemble.c
; Line 4
	push	ebp
	mov	ebp, esp
	sub	esp, 8
; Line 5
	mov	DWORD PTR _x$[ebp], 500			; 000001f4H
; Line 6
	mov	DWORD PTR _y$[ebp], 0
; Line 8
	mov	eax, DWORD PTR _y$[ebp]
	push	eax
	mov	ecx, DWORD PTR _x$[ebp]
	push	ecx
	push	OFFSET $SG9189
	call	_printf
	add	esp, 12					; 0000000cH
; Line 12
	mov	eax, DWORD PTR _x$[ebp]
; Line 13
	mov	DWORD PTR _y$[ebp], eax
; Line 16
	mov	edx, DWORD PTR _y$[ebp]
	push	edx
	mov	eax, DWORD PTR _x$[ebp]
	push	eax
	push	OFFSET $SG9190
	call	_printf
	add	esp, 12					; 0000000cH
; Line 17
	xor	eax, eax
; Line 18
	mov	esp, ebp
	pop	ebp
	ret	0
_main	ENDP
_TEXT	ENDS
```

Our two lines of assembly code (lines 12 and 13) in our C source file are represented on lines 31 and 32.  Notice they aren't exactly the same as we wrote because the C compiler has generated the correct code to access the variables `x` and `y` as stored in memory.

Running the application provides the output below:

```shell
Before assembly, x = 500, y = 0
After assembly, x = 500, y = 500
```

This application is really about showing you how variable assignment works in assembly code in comparison to C.  There is very little difference, although it may take two assembly instructions to perform the assignment if we are assigning the value of a variable to another variable.  Our next application will look at how we assign a non-variable value to a variable.

## Second Inline Assembly Application

Our second application behaves very similar to the first, but now we are only going to work with one variable.  This we will change the value of the single variable in the assembly block using a fixed value.  Our code for this application is below.

```c
#include <stdio.h>

int main(int argc, char **argv)
{
	int x = 0;
	
	printf("Before assembly, x = %d\n", x);
	
	__asm
	{
		// Same as x = 500
		mov x, 500
	}
	
	printf("After assembly, x = %d\n", x);
	return 0;
}
```

The assembly block is essentially the same as the following C code:

```c
x = 500;
```

The assembly of interest this time is as follows:

```assembly
_DATA	SEGMENT
$SG9188	DB	'Before assembly, x = %d', 0aH, 00H
	ORG $+3
$SG9189	DB	'After assembly, x = %d', 0aH, 00H
_DATA	ENDS
; Function compile flags: /Odtp
_TEXT	SEGMENT
_x$ = -4						; size = 4
_argc$ = 8						; size = 4
_argv$ = 12						; size = 4
_main	PROC
; File C:\Users\student\Documents\software-development-2\second.c
; Line 4
	push	ebp
	mov	ebp, esp
	push	ecx
; Line 5
	mov	DWORD PTR _x$[ebp], 0
; Line 7
	mov	eax, DWORD PTR _x$[ebp]
	push	eax
	push	OFFSET $SG9188
	call	_printf
	add	esp, 8
; Line 12
	mov	DWORD PTR _x$[ebp], 500			; 000001f4H
; Line 15
	mov	ecx, DWORD PTR _x$[ebp]
	push	ecx
	push	OFFSET $SG9189
	call	_printf
	add	esp, 8
; Line 16
	xor	eax, eax
; Line 17
	mov	esp, ebp
	pop	ebp
	ret	0
_main	ENDP
_TEXT	ENDS
```

Notice the comment on line 26 -- `000001f4H`.  This is the value 500 in hexadecimal (the H denotes this).  Try it out on a calculator -- convert 1f4 to decimal.  Running this application will provide the following output:

```shell
Before assembly, x = 0
After assembly, x = 500
```

We have now looked at variable assignment in assembly, and you can see how C commands roughly translate to assembly code.  Let us now move on to other operations.

## Using Assembler Operations

Assembly provides a number of standard operations to manipulate numerical values.  One of these is `add`.  This command allows us to add a value to one of the registers.  This is our standard method of adding values together.  To do this we normally perform the following operations in assembly:

- Store first value into a register
- Add second value to the register
- Store the result to memory

This is the standard approach to performing simple arithmetic operations in assembly code.  There are a number of different assembly code instructions that deal with arithmetic operations.  Our application will perform addition.

Our application will add two variables -- `x` and `y` -- and store the result in another variable `z`.  We will use the `ecx` register to undertake our calculation.  Converting our steps above into assembly code we get the following:

```assembly
mov ecx, x
add ecx, y
mov z, ecx
```

Our application code is below:

```c
#include <stdio.h>

int main(int argc, char **argv)
{
	int x = 500;
	int y = 200;
	int z = 0;
	
	// Add using assembly
	__asm
	{
		// Move x into ecx register
		mov ecx, x
		// Add y to ecx register
		add ecx, y
		// Store in z
		mov z, ecx
	}
	printf("z = %d\n", z);
	
  // Add in code
	z = x + y;
	
	return 0;
}
```

The application is the equivalent of the following code.  In fact we also perform the operation at the end of the main application (line 22).  You can examine this as part of an exercise.

```c
z = x + y;
```

Running this application will provide you with the following output:

```shell
z = 700
```

### Exercises

- Try some other arithmetic operations and test the results.  Ensure that you get the result you expected.  The operations to try are:
  - `sub` -- subtraction
  - `imul` -- multiplication
  - We won't try division here as it is a bit more complicated, but the recommended reading will help.
- For each applications you have built in this section (addition, subtraction, multiplication) compare the resulting Assembly code you have written to the one generated by the compiler (such as the command on line 22 in the last example).  Ensure you are getting the same result to ensure you understand the concepts covered.

## Using the Stack

Now that we understand the basic concepts of how simple instructions in C are converted to Assembly code instructions we can move onto starting to understand what happens when we call functions in C.  You might have seen some of the code for this in our Assembly code generated by the compiler, but we haven't really gone into any detail yet.  Before we can really look at function calling, we have to understand a fundamental part of our running application -- *the stack*.

### What is the Stack?

When working with a running application written in a low level language such as C, we have to consider two parts of memory.  The first part -- and the only part we have really been working in -- is the stack.  The other part of memory, *the heap or free store*, we will cover in more detail later in the module when we look at memory management.

The stack can be considered the *working memory* of our application.  It keeps track of the variables that are currently in *scope*.  Variables in scope are the values that we can currently directly access.  Again, we will cover exactly what this means in a later unit.  However, for the moment you should understand that when you call a function that only variables passed into the function are accessible, unless you have any global variables as well.

The stack is therefore a list of the values that you have created during the running of your application using standard variable declaration.  It allows us to grab these variables and use them for our operations. The CPU keeps track of the current stack for us, adding or removing values as they come into and out of scope.

As an example, consider the following piece of code:

```c
void func()
{
	// Enter the function
	// Declare 2 values
	int x = 500;
	int y = 1000;
	{
		// Enter an inner scope
		int z = x + y;
		// Exit inner scope - z removed from stack
	}
	// Exit the function - x and y removed from stack
}
```

The code above operates on the stack as illustrated below.  When we enter the function, we can consider the stack to be empty (it isn't really, but for our example here we can consider it as such).  When we declare our first variable `x` it is added to the stack.  Then `y` and finally `z`.  As each scope is exited, certain values are removed from the stack.  Therefore, we keep track of values that have been declared.

![memory-stack](memory-stack.png)

> **WARNING - This is a Simplified Idea of the Stack**
>
> This is not truly how the stack works in practice.  Space is allocated on the stack well before you actually declare the values.  The stack is in fact a limited resource.  Generally only 1 MB of space is allocated to a stack, and we have an offset on the stack to the various variables that have been declared.  A *stack pointer* keeps track of how much of the stack is in scope, moving up and down based on need.  No values are really *removed* from the stack, the CPU just considers memory beyond the stack pointer as no longer valid and may overwrite it if it wishes.

We will see why we need the stack for this purpose through this unit of the module and some later units.  For just now, we will look at how we work with the stack.

### Working with the Stack

When it comes to working with the stack, we are really only interested in the following two commands:

- `push` -- adds a value to the stack
- `pop` -- removes a value from the stack and stores it in the given location

These two machine instructions are very simple, and only take a single parameter.  For example, if we want to store the value in variable `x` on the stack, we use the command `push x`.  To remove a value from the stack and store it in variable `y` we use `pop y`.  The instructions are simple, **but the idea of how the stack operates is important**.  You should familiarise yourself with the basic concept, and use the next few examples to fully understand what is happening.

### Test Application

Our test application will swap two variables -- `x` and `y` -- using the stack as a swap space.  **We already know that this is not how the C compiler would actually perform this operation, so do not convince yourself that it is**.  Therefore this isn't a real world example.  However, this example does give you a good idea of how the stack operates.

```c
#include <stdio.h>

int main(int argc, char **argv)
{
	int x = 500;
	int y = 200;
	
	__asm
	{
		// Push x onto the stack
		push x
		// Push y onto the stack
		push y
		// Pop stack into x
		pop x
		// Pop stack into y
		pop y
	}
	
	printf("x = %d, y = %d\n", x, y);

	return 0;
}
```

The below figure illustrates how this application operates when executing the Assembly code section (although the stack isn't really empty).  The output of this application is also shown below.

![](push-pop.png)

```shell
x = 200, y = 500
```

## Calling Functions -- `printf`

With our understanding of the stack we can now move onto calling actual functions.  This requires us to set parameters to pass to the function -- which is where the stack comes in.  However, before moving onto how we use the stack to accomplish this, we will look at how we actually `call` a function.

### Calling Procedures in Assembly

To call a procedure in Assembly we use the `call` command.  All this instruction requires is the name of the procedure you wish to call.  For example, to call `printf` we simply use the instruction `call printf`.  This will cause the CPU to *jump* to the set of instructions that define the `printf` procedure.  At the end of the procedure, the CPU returns to where it encountered the `call` operation and continues executing the instructions.  This is achieved by the `ret` instruction.

### Setting the Stack

As you should realise by now, calling a function / procedure is only one part of the puzzle.  We also have to pass parameters into the call for the procedure to use.  This is where the stack comes in.

Before calling a procedure, you have to add the values of the parameters to the stack.  This is because the called procedure needs a *copy* of these values (we will look at call conventions later in the module).  As we need to create a copy, and the procedure needs to know where these values are stored (based on it's parameter list), we have to push these values onto the stack.

As an example, consider a function defined as follows:

```c
void func(int x, int y) ...
```

We need to set the values of `x` and `y` for the procedure to operate.  For example, let us say we called the procedure as follows:

```c
func(1000, 2000);
```

To actually call this function in assembly we would have to use the following instructions:

```assembly
push 2000
push 1000
call func
```

Notice that we push the parameter values from right to left, not left to right.  This is because the procedure will look at the top of the stack as the starting point for its parameters and work downwards.  Therefore, the first parameter for the procedure (`x` in our example) has to be at the top of the stack, the second one value down, the third two values down, etc.  **This is another important idea to realise and is underpinned by an understanding of how the stack works -- last-in, first-out.**

### Clearing the Stack

Setting the stack for use by a procedure is what you should do before you call it.  After the procedure has returned you need to clean up the stack again.  This is done by popping the relevant number of values of the stack (actually in practice there is a better way -- see the exercises).  In our example we will pop any stack values into the `ebx` register to clean the stack.

### Example Application

To review, we use the following three stage process when calling a procedure in Assembly code:

1. Set the stack with the relevant parameters.  Remember we push these values in reverse order than we use them.

2. Call the procedure.

3. Clean the stack of any set parameters.

The following application illustrates this basic process by returning to our simple *Hello World* example, but this time using inline assembly to perform the actual call.

```c
#include <stdio.h>

int main(int argc, char **argv)
{
	char *message = "Hello World!\n";
	
	__asm
	{
		// Push message onto the stack
		push message
		// Call printf
		call printf
		// Clean up stack - pop into ebx
		pop ebx
	}
	
	return 0;
}
```

**Compile this code and generate the Assembly**.  This section of interest is given below:

```assembly
_DATA	SEGMENT
$SG9188	DB	'Hello World!', 0aH, 00H
_DATA	ENDS
; Function compile flags: /Odtp
_TEXT	SEGMENT
_message$ = -4						; size = 4
_argc$ = 8						; size = 4
_argv$ = 12						; size = 4
_main	PROC
; File C:\Users\student\Documents\software-development-2\call.c
; Line 4
	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx
; Line 5
	mov	DWORD PTR _message$[ebp], OFFSET $SG9188
; Line 10
	push	DWORD PTR _message$[ebp]
; Line 12
	call	_printf
; Line 14
	pop	ebx
; Line 17
	xor	eax, eax
; Line 18
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_main	ENDP
_TEXT	ENDS
```

There are two lines we will look at in this example:

- Line 19 is where the parameter is set in Assembly code.  Here we are providing a memory location to `printf`.  Remember how our strings are stored.
- Line 23 is where our stack cleaning occurs.

Running this application will display the following:

```c
Hello World!
```

Not much difference to the previous *Hello World* example in pure C.  However, you now know the Assembly code that the C compiler has generated.

### Exercise

Modify the inline assembly so that you call `printf` multiple times, but do not clean the stack after each call (no popping into `ebx`). What happens?

## Calling Functions -- Writing your Own

Let us now see what happens when we create and call our own function in C.  To do this we will write a small subtraction function that will take two values as parameters and return the difference.  The code for this sample is given below:

> **Getting Return Values from a Function Call**
>
> So far we haven't covered how we get our return value after a function call.  Well, this value has been stored for us in one of the registers -- `eax`.  This means that we can retrieve it from there if we wish.  For example, let us say we are going to write the following code:
>
> ```c
> int z = sub(1000, 500);
> ```
>
> In Assembly code this becomes the following set of instructions (if we do naive stack cleaning):
>
> ```assembly
> push 500
> push 1000
> call sub
> mov z, eax
> pop ebx
> pop ebx
> ```
>
> That line 4 is the important one.  This is where we store the result of the function call into our required memory location.  It is the job of the function to store the function result into the `eax` register.

```c
#include <stdio.h>

int sub(int x, int y)
{
	return x - y;
}

int main(int argc, char **argv)
{
	int result = 0;
	
	__asm
	{
		// Push 500 onto stack
		push 500
		// Push eax onto stack
		push 200
		// Call sub
		call sub
		// Move eax into result
		// eax contains the result of the call
		mov result, eax
		// Clean up stack - pop into ebx
		pop ebx
		pop ebx
	}   

	printf("result = %d\n", result);
	
	return 0;
}
```

You should understand this code enough so that we don't have to explain it in any detail.  The more important part if the generated assembly code:

```assembly
_DATA	SEGMENT
$SG9194	DB	'result = %d', 0aH, 00H
_DATA	ENDS
; Function compile flags: /Odtp
_TEXT	SEGMENT
_result$ = -4						; size = 4
_argc$ = 8						; size = 4
_argv$ = 12						; size = 4
_main	PROC
; File C:\Users\student\Documents\software-development-2\call2.c
; Line 9
	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx
; Line 10
	mov	DWORD PTR _result$[ebp], 0
; Line 15
	push	500					; 000001f4H
; Line 17
	push	200					; 000000c8H
; Line 19
	call	_sub
; Line 22
	mov	DWORD PTR _result$[ebp], eax
; Line 24
	pop	ebx
; Line 25
	pop	ebx
; Line 28
	mov	eax, DWORD PTR _result$[ebp]
	push	eax
	push	OFFSET $SG9194
	call	_printf
	add	esp, 8
; Line 30
	xor	eax, eax
; Line 31
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_main	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
_TEXT	SEGMENT
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_sub	PROC
; File C:\Users\student\Documents\software-development-2\call2.c
; Line 4
	push	ebp
	mov	ebp, esp
; Line 5
	mov	eax, DWORD PTR _x$[ebp]
	sub	eax, DWORD PTR _y$[ebp]
; Line 6
	pop	ebp
	ret	0
_sub	ENDP
_TEXT	ENDS
```

The lines of interest here are as follows:

- Lines 19 and 21 set our stack.  Remember we are pushing the values in reverse order.  This means that `x` is 200 and `y` is 500.
- Line 23 issues the `call` instruction.
- Line 25 is where we retrieve the return value of the function call from the `eax` register and store it in `result`.
- Lines 27 and 29 clean up the stack.
- Line 49 is where the `sub` procedure is defined
- Lines 55 and 56 is where the calculation takes place.  Notice we use the `eax` register.  This is where the result is stored.
- Line 59 is where the procedure returns, going back to line 25 to continue execution.

Running this application gives the following result:

```shell
result = -300
```

## Loops

In this section we will look at how we work with branching statements to build loop like code in Assembly.  To do this we will create an application that turns every third letter in a string to an `X` and then prints the result.  This requires us to use three new Assembly instructions:

- `jmp` -- causes the CPU to jump to the instruction at the given label.
- `cmp` -- compares two values and sets some flag values on the CPU based on the comparison.
- `jge` -- causes the CPU to jump to the instruction at the given label if the greater than or equal to flags were set after a comparison.

The comparison and jump instructions are the basis of allowing us to build any branching statement in Assembly.  This takes a bit more work than standard assignment and function calling Assembly code.  However, the basic premise of converting C code to assembly still remains.

> **Labels and Jumping**
>
> In Assembly we have to place labels in our code and tell the CPU to jump to these instructions when we need it to.  This is how branching works on the CPU.  However, you may have been warned about writing such code in other programming classes.  This is the classic `goto` statement idea, which leads to *spaghetti code*.  C (and by extension C++) provides a `goto` statement -- **and you should never use it!**  `goto` as a command has its uses but you will never need it for anything but very, very particular purposes.  It is hard to debug and hard to track how your application works.  Let the compiler create any necessary labels and jumps.  You should avoid it.

For our application, the below algorithm provides an outline of the operations to occur. **Walk through this algorithm by hand to ensure you understand it.**

```pseudocode
-- str is the string to manipulate
-- len is the length of this string

BEGIN ASSEMBLY_LOOP
    i := 0
    GOTO CHECK_i
INCREMENT_i:
    eax := i
    eax := eax + 1
    i := eax
    -- Check i < length of str
    IF i EQUALS len THEN
        GOTO EXIT
    END IF
CHECK_i:
    ecx := i
    ecx := ecx mod 3 -- get remainder
    IF ecx NOT EQUALS 0 THEN
        GOTO INCREMENT_i
    ELSE
        str[i] := 'X'
        GOTO INCREMENT_i
    END IF
EXIT:
		-- do nothing
```

The code we are going to use is as follows:

```c
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

int main(int argc, char **argv)
{
    // String to change
    char *message = "Hello, world!";
    // Length of the string
    int len = strlen(message);
    int i;

    __asm
    {
        // i = 0
        mov i, 0
        // GOTO CHECK_i
        jmp CHECK_i
    INCREMENT_i:
        // eax = i
        mov eax, i
        // eax = eax + 1
        inc eax
        // i = eax
        mov i, eax
        // Check i < len
        cmp eax, len
        // IF equals goto exit
        je EXIT
    CHECK_i:
        // eax = i
        mov eax, i
        // Divide operation
        // First set edx to 0
        xor edx, edx
        // Set ebx to 3
        mov ebx, 3
        // Divide eax by ebx
        div ebx
        // edx contains remainder
        cmp edx, 0
        // Jump if not equals 0
        jnz INCREMENT_i
        // Set str[i] to X
        // Put memory location of message in ecx
        mov ecx, message
        // Add i to set memory location - i bytes into message
        add ecx, i
        // Set the value contained in this memory location to 'X'
        // [ecx] means the memory location stored in ecx rather than the value of ecx
        mov [ecx], 'X'
        // Goto to INCRMEENT_i
        jmp INCREMENT_i
    EXIT:
    }

    // Print the string
    printf("%s\n", message);

    return 0;
}
```

This follows a classic *sequence-selection-iteration* style.  This is all the CPU can do.  High level languages allow us to abstract further and further from the low level code representation understood by the CPU to instructions that are understandable by the programmer.  Notice the work put in to allow us to implement a loop in Assembly against our C code.

Running this application gives us an output similar to the following:

```shell
XelXo,XwoXldX
```

### Exercise

At the moment, this program doesn't actually do what we want due to zero-based indexing of our strings. Our output should be:

```shell
HeXloX wXrlX!
```

Can you fix it?

## Why did we Just Look at Assembly?

Just to end this unit, we will reflect on why we have looked at Assembly.  The main point here is to understand how C code is converted into Assembly code.  It is rare that you would write the type of Assembly code we have, but hopefully you see the similarity between standard C code and what the machine executes as instructions.  Remember that a typical processor these days will have a clock speed between 2 and 4 GHz.  This implies that the CPU is executing 2 to 4 billion of these instructions per second (again, this is a simplified description -- it isn't as easy as that).  The fact that C compiles to a small, compact Assembly instructions is the reason C is considered a fast language.

## Additional Resources

Our aim in this unit was to give you an understanding of how C code converts to Assembly.  As such, we haven't delved too deeply into a wide range of aspects in low level programming.  However, if you are interested the following link provides a reasonable starting position:

<http://www.cs.virginia.edu/~evans/cs216/guides/x86.html>{:target="_blank"}

## Exercises

1. Still using make files?  Make sure that you are!
2. Investigate the `struct` examples from the previous unit.  You should generate the Assembly code from some of the previous examples and examine how C works with `struct` values.  Try your best to try to figure out what is happening, but don't let yourself get too caught up if you are unsure.  Ask for help if needed.
3. Using the `esp` register.  The `esp` register is the stack pointer, and can be modified to tell the CPU where it should consider the stack to be valid.  When we looked at function calling, we used `pop` to clear the values we added to the stack.  This is efficient for one parameter, but not the most efficient for greater numbers of parameters (lots of `pop` instructions).  A better method is to set the `esp` register so that it points back to where the valid stack ends.  Can you change some of our example applications to achieve this? *Hint - the Assembly code from some of the other applications where you have called functions may help you here.*  The `ebp` register (*stack base pointer*) is also used.
4. **For the Brave** -- Write an application, using inline assembly as much as possible, that prompts the user for their name and reads in the result using `fgets`.  This is not as simple as it sounds.
5. **For the Brave** -- Write an application, using inline assembly as much as possible, that works on an array of 10 integers.  The application will have two `for` loops.  The first loop will set the value of the numbers in the array from 0 to 9.  The second `for` loop will print the entries and sum the total.  At the end of the second `for` loop the total should be displayed.

